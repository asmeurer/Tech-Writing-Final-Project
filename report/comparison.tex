Below is a reconstruction of the pseudocode for the algorithm
\texttt{Pol\-y\-Risch\-DE\-No\-Can\-cel2} from page 209 of Bronstein's
book \cite{bronstein2005symbolic}. Below that is the implementation of
the same algorithm in SymPy.  This algorithm is one of the the
subroutines of the algorithm to solve the Risch Differential Equation
(see Section \ref{description}).  

%\begin{multicols}{2}
%\tiny
\footnotesize
% there's also \scriptsize and \tiny
\begin{algorithm}[H]
    \SetCommentSty{textrm}
    \SetFillComment
    \dontprintsemicolon
%    \TitleOfAlgo{{\bf PolyRischDENoCancel2}($b$, $c$, $D$, $n$)}
%    \SetAlgorithmName{{\bf PolyRischDENoCancel2}($b$, $c$, $D$, $n$)}
    {\bf PolyRischDENoCancel2}($b$, $c$, $D$, $n$)
    \tcc*[f]{Poly Risch d.e. -- no cancellation}\;
    \BlankLine
    \Indp
%    \tcc*[f]{Poly Risch d.e. -- no cancellation}}\;
    \BlankLine
    \tcc*[f]{Given a derivation $D$ on $k[t]$, $n$ either an integer or
    $+\infty$, and $b, c\in k[t]$ with $\mathrm{deg}(b)< \delta(t) - 1$
    and either $D = d/dt$ or $\delta(t) \geq 2$, return either ``no
    solution'', in which case the equation $Dq + bq = c$ has no solution
    of degree at most $n$ in $k[t]$, or a solution $q \in k[t]$ of this
    equation with $\mathrm{deg}(q) \leq n$, or the tuple $(h, b_0, c_0)$
    such that $h \in k[t]$, $b_0,c_0\in k[t]$, and for any solution
    $q\in k[t]$ of degree at most $n$ of $Dq + bq = c$, $y = q - h$ is a
    solution in $k$ of $Dy + b_0y=c_0$.}\;
    \BlankLine
    $q \leftarrow 0$\;
    \While{$c\neq 0$}{
        \lIf{$n=0$}{$m\leftarrow 0$} \lElse{$m\leftarrow \mathrm{deg}(c)
        = \delta(t) + 1$}\;
        \lIf{$n < 0$ or $m < 0$ or $m > n$}{\Return ``no solution''}\;
        \lIf{$m > 0$}{$p\leftarrow (\mathrm{lc}(c)/(m\lambda(t)))t^m$}\;
        \Else(\tcc*[f]{$m =  0$}){
            \lIf{$\mathrm{deg}(b) \neq \mathrm{deg}(c)$}{\Return ``no
            solution''}\;
            \lIf{$\mathrm{deg}(b) = 0$}{\Return $(q, c, b)$}\;
            $p \leftarrow \mathrm{lc}(c)/\mathrm{lc}(b)$\;
        }
        $q \leftarrow q + p$\;
        $n \leftarrow m - 1$\;
        $c \leftarrow c - Dp - bp$\;
    }
    \Return $q$
\end{algorithm}
\input{polyrischdenocancel2_head}
\input{polyrischdenocancel2}
\normalsize
%\end{multicols}

This function is a good example of a function that translates almost
exactly from pseudocode into SymPy Python.  Therefore, any differences
are the result of the implementation details of SymPy.  Aside from the
syntax differences between the pseudocode and Python, there are very
little such differences.  The main difference is that in SymPy we must
use the \texttt{Poly} class to do polynomial manipulations.  For
example, we have {\tt p = Poly(c.as\_poly(t).LC()/b.as\_poly(t).LC(),
t)} instead of the $p \leftarrow \mathrm{lc}(c)/\mathrm{lc}(b)$ from the
pseudocode.  Thus, this example serves to show some of the advantages of
using Python and SymPy to when working with an algorithm as complex as
the Risch Algorithm.  Because the SymPy Python code is almost exactly
the same as the pseudocode, it is just as easy to read and understand.
This also makes much easier to maintain against the pseudocode, since
any typo in the Python will be easy to spot.
